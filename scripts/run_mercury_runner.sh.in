#!/bin/bash

#
# Copyright (c) 2017, Carnegie Mellon University.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the University nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
# HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
# WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

### instant death on misc errors ###
set -euo pipefail

######################
# Tunable parameters #
######################
subnet=${1:-"10.92"}

## subnet="11.128"      # trinity / trinitite

## subnet="10.53"       # susitna - fge0
## subnet="10.51"       # susitna - eth0
## subnet="10.93"       # narwhal - eth1
## subnet="10.92"       # narwhal - eth0

# "n" - normal send run: RPC, vary request size and limit
n_protos=("bmi+tcp" "cci+tcp")                  # protocols to test
n_sizes=(64 1024 4096)                          # RPC snd size ("-i" flag)
n_limits=(1 2 4 8 16)                           # outstanding RPCs ("-l" flag)
n_repeats=2                                     # repeat runs
n_nrpcs=100000                                  # nrpcs in 1 run ("-c" flag)
n_timeout=120                                   # timeout  ("-t" flag)

# "b" - bulk read run: RPC, vary bulk read size and limit
b_protos=("bmi+tcp" "cci+tcp")                  # protocols to test
b_Sizes=(2m)                                    # bulk sizes ("-S" flag)
b_limits=(1 2)                                  # outstanding RPCs ("-l" flag)
b_repeats=5                                     # repeat runs
b_nrpcs=10000                                   # nrpcs in 1 run ("-c" flag)
b_timeout=300                                   # timeout  ("-t" flag)

dryrun=0                                        # set to 1 for script debug

instances=(1)                                   # currently not changing this
###############
# Core script #
###############

source @CMAKE_INSTALL_PREFIX@/scripts/common.sh

message "Script begin..."
# keep track of start time so we can see how long this takes
timein=`date`

get_jobdir
gen_hostfile

runner="${dfsu_prefix}/bin/mercury-runner"

message ">>> Output is available in $jobdir"

# get our two hostnames
host1=$(echo "$all_nodes" | sort | head -n 1)
host2=$(echo "$all_nodes" | sort | head -n 2 | tail -n 1)

#
# convert hostnames to IPs using hostname -I on remote nodes
# and put results in host*-ips.txt in $jobdir, load into
# host1_ip and host2_ip, also taking $subnet into consideration
#
do_mpirun 1 1 "" $host1 "hostname -i" "" $logfile $jobdir/host1-ips.txt
do_mpirun 1 1 "" $host2 "hostname -i" "" $logfile $jobdir/host2-ips.txt
host1_ip=$(cat $jobdir/host1-ips.txt | tr ' ' '\n' | grep $subnet | head -1)
if [ -z $host1_ip ]; then die "wrong subnet"; fi
host2_ip=$(cat $jobdir/host2-ips.txt | tr ' ' '\n' | grep $subnet | head -1)
if [ -z $host2_ip ]; then die "wrong subnet"; fi
message ">>> Host 1: hostname = $host1, ip = $host1_ip"
message ">>> Host 2: hostname = $host2, ip = $host2_ip"

#
# run_one: run one instance
#
# uses: jobdir, host1, host2, host1_ip, host2_ip, dryrun
# Arguments:
# @1 protocol to use
# @2 number of mercury instances
# @3 req size ("-s")
# @4 bulk send size ("-S")
# @5 outstanding RPC limit ("-l")
# @6 current current iteration number
# @7 number of rpcs ("-c")
# @8 number repeats we target
# @9 timeout
run_one() {
    proto="$1"
    num="$2"
    reqsz=$3
    bulksz=$4
    limit=$5
    iter=$6
    nrpcs=$7
    repeats=$8
    timeo=$9

    now=`date`

    message ""
    message "====================================================="
    message "Starting new test at: ${now}"
    message "Testing protocol '$proto' with $num Mercury instances"
    message "reqsz=${reqsz:-'n/a'}, bulksz=${bulksz:-'n/a'}, limit=$limit, nrpcs=$nrpcs"
    message "Iteration $iter out of $repeats"
    message "====================================================="
    message ""

    saddress="${proto}://${host1_ip}:%d"
    caddress="${proto}://${host2_ip}:%d"

    # generate log file names (maybe they should be passed in?)
    if [ ! -d $jobdir/$proto ]; then
        mkdir -p $jobdir/$proto
    fi
    if [ x$bulksz != x ]; then
        clogfile=$jobdir/$proto/bcli-$proto-$num-$bulksz-$limit-$iter-log.txt
        slogfile=$jobdir/$proto/bsrv-$proto-$num-$bulksz-$limit-$iter-log.txt
    else
        clogfile=$jobdir/$proto/ncli-$proto-$num-$reqsz-$limit-$iter-log.txt
        slogfile=$jobdir/$proto/nsrv-$proto-$num-$reqsz-$limit-$iter-log.txt
    fi

    # build command line
    # use slogfile for log; we'll move .0/.1 at the end
    cmd="$runner -c ${nrpcs} -l $limit -M -q -r $iter -s $slogfile -t ${timeo}"
    if [ x$bulksz != x ]; then
        cmd="$cmd -S $bulksz -L $bulksz"
    fi
    if [ x$reqsz != x ]; then
        cmd="$cmd -i $reqsz"
    fi

    the_cmd="$cmd -m s $num $saddress $caddress"

    # start the run
    message "!!! NOTICE !!! starting run (Instances: $num, Address spec: $saddress/$caddress)..."
    if [ $dryrun = 1 ]; then
        message "DRY RUN CMD @ $host1,$host2 -> $the_cmd"
    else
        do_mpirun 2 1 "" "$host1,$host2" "$the_cmd" "" "$logfile" || \
          message "!!! NOTICE !!! app exited with error code"
    fi

    sleep 0.1

    # Collect return codes
    if [ x$dryrun != x ]; then
        the_ret=0      # fake return values
    else
        the_ret=$?
    fi

    if [[ $the_ret != 0 ]]; then
        message "!!! ERROR !!! program returned $the_ret."
    else
        message "Test completed successfully."
    fi

    # now put logs in correct place
    if [ -f ${slogfile}.0 ]; then
        mv ${slogfile}.0 $slogfile
    fi
    if [ -f ${slogfile}.1 ]; then
       mv ${slogfile}.1 $clogfile
    fi

    now=`date`
    message "Finished at ${now}"
}

# do normal test first
now=`date`
message "== Starting normal tests: ${now}"
for proto in ${n_protos[@]-}; do
    for num in ${instances[@]-}; do
        for sz in ${n_sizes[@]-}; do
            for lm in ${n_limits[@]-}; do

                if [[ $proto == "bmi+tcp" && $num -gt 1 ]]; then
                    continue;  # BMI doesn't do well with >1 instances
                fi

                i=1
                while [ $i -le $n_repeats ]; do
                    run_one $proto $num $sz "" $lm $i $n_nrpcs \
                            $n_repeats $n_timeout
                    i=$((i + 1))
                done

            done
        done
    done
done
now=`date`
message "DONE normal tests: ${now}"

message "Generate result files"
for proto in ${n_protos[@]-}; do
    for num in ${instances[@]-}; do
        for sz in ${n_sizes[@]-}; do
            find ${jobdir}/${proto} -iname "n*-${proto}-${num}-${sz}-*" | xargs cat | \
                ${dfsu_prefix}/scripts/process_runner.pl > \
                ${jobdir}/norm-${proto}-${num}-${sz}.result
            if [ ! -s ${jobdir}/norm-${proto}-${num}-${sz}.result ]; then
                message "!!! WARN !!! NO RESULTS: ${jobdir}/norm-${proto}-${num}-${sz}"
                rm -f ${jobdir}/norm-${proto}-${num}-${sz}.result
            fi
        done
    done
done
message "DONE generate result files"


# do bulk test next
now=`date`
message "== Starting bulk tests: ${now}"
for proto in ${b_protos[@]-}; do
    for num in ${instances[@]-}; do
        for sz in ${b_Sizes[@]-}; do
            for lm in ${b_limits[@]-}; do

                if [[ $proto == "bmi+tcp" && $num -gt 1 ]]; then
                    continue;  # BMI doesn't do well with >1 instances
                fi

                i=1
                while [ $i -le $b_repeats ]; do
                    run_one $proto $num "" $sz $lm $i $b_nrpcs \
                            $b_repeats $b_timeout
                    i=$((i + 1))
                done

            done
        done
    done
done
now=`date`
message "DONE bulk tests: ${now}"

message "Generate result files"
for proto in ${b_protos[@]-}; do
    for num in ${instances[@]-}; do
        for sz in ${b_Sizes[@]-}; do
            find ${jobdir}/${proto} -iname "b*-${proto}-${num}-${sz}-*" | xargs cat | \
                ${dfsu_prefix}/scripts/process_runner.pl > \
                ${jobdir}/bulk-${proto}-${num}-${sz}.result
            if [ ! -s ${jobdir}/bulk-${proto}-${num}-${sz}.result ]; then
                message "!!! WARN !!! NO RESULTS: ${jobdir}/bulk-${proto}-${num}-${sz}"
                rm -f ${jobdir}/bulk-${proto}-${num}-${sz}.result
            fi
        done
    done
done
message "DONE generate result files"

message "== Listing results ..."
for result in $(find $jobdir -iname "*.result"); do
    message ""
    message "$result"
    cat $result | tee -a $logfile
    message ""
    message "----------"
done
message "DONE listing results"

# overall time
timeout=`date`
message "Script complete."
message "start: ${timein}"
message "  end: ${timeout}"

exit 0
